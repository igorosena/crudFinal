"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.autoload = exports.defaultConfig = void 0;
const ethers_1 = require("ethers");
const proxies_js_1 = require("./proxies.js");
const types_js_1 = require("./types.js");
const loaders_js_1 = require("./loaders.js");
const disasm_js_1 = require("./disasm.js");
function isAddress(address) {
    return address.length === 42 && address.startsWith("0x") && Number(address) >= 0;
}
exports.defaultConfig = {
    onProgress: (_) => { },
    onError: (phase, err) => { console.error(phase + ":", err); return false; },
};
async function autoload(address, config) {
    const onProgress = config.onProgress || exports.defaultConfig.onProgress;
    const onError = config.onError || exports.defaultConfig.onError;
    const provider = (0, types_js_1.CompatibleProvider)(config.provider);
    const result = {
        address,
        abi: [],
        proxies: [],
    };
    if (config === undefined) {
        throw new Error("autoload: config is undefined, must include 'provider'");
    }
    let abiLoader = config.abiLoader;
    if (abiLoader === undefined)
        abiLoader = loaders_js_1.defaultABILoader;
    if (!isAddress(address)) {
        onProgress("resolveName", { address });
        if (config.addressResolver) {
            address = await config.addressResolver(address);
        }
        else {
            address = await provider.getAddress(address);
        }
    }
    onProgress("getCode", { address });
    const bytecode = await provider.getCode(address);
    if (!bytecode)
        return result;
    const program = (0, disasm_js_1.disasm)(bytecode);
    result.proxies = program.proxies;
    const facets = {
        [address]: [],
    };
    if (result.proxies.length === 1 && result.proxies[0] instanceof proxies_js_1.DiamondProxyResolver) {
        onProgress("loadDiamondFacets", { address });
        const diamondProxy = result.proxies[0];
        const f = await diamondProxy.facets(provider, address);
        Object.assign(facets, f);
    }
    else if (result.proxies.length > 0) {
        result.followProxies = async function (selector) {
            for (const resolver of result.proxies) {
                onProgress("followProxies", { resolver: resolver, address });
                const resolved = await resolver.resolve(provider, address, selector);
                if (resolved !== undefined)
                    return await autoload(resolved, config);
            }
            onError("followProxies", new Error("failed to resolve proxy"));
            return result;
        };
        if (config.followProxies) {
            return await result.followProxies();
        }
    }
    if (abiLoader) {
        onProgress("abiLoader", { address, facets: Object.keys(facets) });
        const loader = abiLoader;
        try {
            const addresses = Object.keys(facets);
            const promises = addresses.map(addr => loader.loadABI(addr));
            const results = await Promise.all(promises);
            const abis = Object.fromEntries(results.map((abi, i) => {
                return [addresses[i], abi];
            }));
            result.abi = pruneFacets(facets, abis);
            if (result.abi.length > 0)
                return result;
        }
        catch (error) {
            if (onError("abiLoad", error) === true)
                return result;
        }
    }
    onProgress("abiFromBytecode", { address });
    result.abi = (0, disasm_js_1.abiFromBytecode)(program);
    if (!config.enableExperimentalMetadata) {
        result.abi = stripUnreliableABI(result.abi);
    }
    result.abi.push(...Object.values(facets).flat().map(selector => {
        return {
            type: "function",
            selector,
        };
    }));
    let signatureLookup = config.signatureLookup;
    if (signatureLookup === undefined)
        signatureLookup = loaders_js_1.defaultSignatureLookup;
    if (!signatureLookup)
        return result;
    onProgress("signatureLookup", { abiItems: result.abi.length });
    let promises = [];
    for (const a of result.abi) {
        if (a.type === "function") {
            promises.push(signatureLookup.loadFunctions(a.selector).then((r) => {
                if (r.length >= 1) {
                    a.sig = r[0];
                    const extracted = JSON.parse(ethers_1.Fragment.from("function " + a.sig).format("json"));
                    if (extracted.outputs.length === 0) {
                        delete (extracted.outputs);
                    }
                    Object.assign(a, extracted);
                }
                if (r.length > 1)
                    a.sigAlts = r.slice(1);
            }));
        }
        else if (a.type === "event") {
            promises.push(signatureLookup.loadEvents(a.hash).then((r) => {
                if (r.length >= 1) {
                    a.sig = r[0];
                    Object.assign(a, JSON.parse(ethers_1.Fragment.from("event " + a.sig).format("json")));
                }
                if (r.length > 1)
                    a.sigAlts = r.slice(1);
            }));
        }
    }
    await Promise.all(promises);
    return result;
}
exports.autoload = autoload;
function stripUnreliableABI(abi) {
    const r = [];
    for (const a of abi) {
        if (a.type !== "function")
            continue;
        r.push({
            type: "function",
            selector: a.selector,
        });
    }
    return r;
}
function pruneFacets(facets, abis) {
    const r = [];
    for (const [addr, abi] of Object.entries(abis)) {
        const allowSelectors = new Set(facets[addr]);
        if (allowSelectors.size === 0) {
            r.push(...abi);
            continue;
        }
        for (let a of abi) {
            if (a.type !== "function") {
                r.push(a);
                continue;
            }
            a = a;
            let selector = a.selector;
            if (selector === undefined && a.name) {
                selector = ethers_1.FunctionFragment.getSelector(a.name, a.inputs);
            }
            if (allowSelectors.has(selector)) {
                r.push(a);
            }
        }
    }
    return r;
}
//# sourceMappingURL=auto.js.map